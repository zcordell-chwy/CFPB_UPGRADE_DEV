<?php
/*
SlimBrowscap
@author: J. Hilgeman
@date: 2015-02-27

A pure-PHP class designed to get the friendly name of a browser by using
browscap data from www.browscap.org.

Usage:
// After running GenerateData()...
$CI = get_instance();
$CI->load->library('slimbrowscap')
echo $CI->slimbrowscap->GetFriendlyBrowser();


GetFriendlyBrowser()
Loads in the major and minor browscap JSON files generated by the GenerateData
method, and then runs the current user agent string against the regexes to 
try and find a friendly name for the browser.


GenerateData()
Generates two JSON files that are simply arrays of regular expressions that 
match against the HTTP_USER_AGENT header and return a friendly browser name.

The JSON files are split into major and minor browsers to reduce the amount
of unnecessary data loaded into memory and to reduce the number of regexes
being executed in order to find the right one. The major file is also sorted
in order of most likely browsers to least likely (IE, then Firefox, etc...).

INSTRUCTIONS:
1. Download the browscap.json file from http://www.browscap.org.
2. Create a script that includes the below function and run it like so:
   ProcessBrowscap("/path/to/browscap.json");
3. It should take about 20 - 60 seconds to process the file.

NOTE: This is dealing with publically-available data, so this entire 
      generation process can be run on a workstation and then have the
      results be uploaded afterwards. This may be necessary if the server
      cannot handle the memory necessary during the processing.
*/
class SlimBrowscap
{
	public $majorFile = "/vhosts/cfpbfi/euf/assets/browscap.major";
	public $minorFile = "/vhosts/cfpbfi/euf/assets/browscap.minor";
	
	public $renameIE = true;

	public function GetFriendlyBrowser($http_user_agent = null)
	{
		// Default to the value sent by the browser
		if($http_user_agent == null) { $http_user_agent = $_SERVER["HTTP_USER_AGENT"]; }

		// Check the major file first
		$result = $this->_GetFriendlyBrowser($http_user_agent, $this->majorFile);
		if(!is_bool($result))
		{
			if($this->renameIE && (strpos($result,"IE ") === 0))
			{
				$result = preg_replace("@^IE @","Internet Explorer ",$result);
			}
			return $result;
		}
		
		// Check the minor file next
		$result = $this->_GetFriendlyBrowser($http_user_agent, $this->minorFile);
		if(!is_bool($result)) { return $result; }

		// Default name
		return "Other Browser ({$http_user_agent})";
	}
	
	private  function _GetFriendlyBrowser($http_user_agent, $file)
	{
		if(file_exists($file))
		{
			// Read in the file
			$arr = json_decode(file_get_contents($file),true);
			
			// Run the regexes
			foreach($arr as $regex => $name)
			{
				if(strpos($regex,"#") === false) { $delimiter = "#"; }
				elseif(strpos($regex,"@") === false) { $delimiter = "@"; }
				elseif(strpos($regex,"%") === false) { $delimiter = "%"; }
				if(preg_match($delimiter . $regex . $delimiter,$http_user_agent)) { return $name; }
			}
		}
		
		return false;
	}
	
	
	
	public function GenerateData($inFile = "./browscap.json", $verbose = false)
	{
		// ##################################################
		// PHASE 1 :: PROCESS BROWSCAP.JSON INTO MERGED ARRAY
		// ##################################################
		
		// Read the file
		$arr = json_decode(file_get_contents($inFile),true);
		$merged = array();
		$count = 0;
	
		if($verbose)
		{
			echo "Starting count: " . count($arr) . "\n";
			echo time() . " :: Processing";
		}
		
		// Process the raw browscap.json data
		foreach($arr as $key => $item_json)
		{
			// Skip comments
			if(is_array($item_json)) { continue; }
	
			// Sub data is still JSON-encoded
			$item = json_decode($item_json,true);
			
			// Data in the file is all delta, so we need to merge it with the parent 
			// results to get the final data set.
			if(array_key_exists("Parent",$item))
			{
				if(isset($merged[$item["Parent"]]))
				{
					$item = array_merge($merged[$item["Parent"]],$item);
				}
			}
			
			// Strip out unused properties to reduce memory overhead
			unset($item["Frames"]);
			unset($item["IFrames"]);
			unset($item["Tables"]);
			unset($item["Cookies"]);
			unset($item["BackgroundSounds"]);
			unset($item["JavaScript"]);
			unset($item["VBScript"]);
			unset($item["JavaApplets"]);
			unset($item["ActiveXControls"]);
			unset($item["Platform_Version"]);
			unset($item["Platform"]);
			unset($item["Win16"]);
			unset($item["Win32"]);
			unset($item["Win64"]);
			unset($item["Alpha"]);
			unset($item["Beta"]);
			unset($item["AolVersion"]);
			
			// We can probably eliminate almost every property except for Comment and Crawler, but for now that should do it.
			
			// Convert true/false strings into booleans
			foreach($item as $k => $v)
			{
				if($v === "false") { $item[$k] = false; }
				elseif($v === "true") { $item[$k] = true; }
				elseif((strpos($k,"Ver") === false))
				{
					if($v == "0") { $item[$k] = false; }
					elseif($v == "1") { $item[$k] = true; }
				}
			}
			
			// Store in merged array
			$merged[$key] = $item;
			
			
			if($verbose)
			{
				$count++;
				if(($count % 5000) == 0) { echo "."; }
			}
		}
	
		if($verbose)
		{
			echo "\n";
			echo time() . " :: Done loading!\n";
			echo "Processed count: " . count($merged) . "\n";
		}
		
		// Don't need all this data anymore
		unset($arr);
	
		// ########################################################
		// PHASE 2 :: FILTER OUT INVALID BROWSERS (SPIDERS, ETC...)
		// ########################################################
		
		if($verbose)
		echo time() . " :: Filtering";
		
		$major_browsers = array();
		$count = 0;
		$crawlers = 0;
		$fakes = 0;
		
		// Go through merged results
		foreach($merged as $key => $item)
		{
			$valid = true;
			
			// Eliminate parent entries
			if(isset($item["Parent"]) && ($item["Parent"] == "DefaultProperties"))
			{
				$valid = false;
			}
			
			// Eliminate crawlers
			if($valid && (isset($item["Crawler"]) && ($item["Crawler"])))
			{
				$crawlers++;
				$valid = false;
			}
			
			// Eliminate fake browsers
			if($valid && (strpos($key,"Fake") === 0))
			{
				$fakes++;
				$valid = false;
			}
			if($valid && (array_key_exists("Comment",$item) && (strpos($item["Comment"],"Fake") !== false)))
			{
				$fakes++;
				$valid = false;
			}
			
			// Group and store valid entries
			if($valid)
			{
				// Determine group
				$group = "Other";
				if(strpos($item["Comment"],"IE ") === 0) { $group = "IE"; }
				if(strpos($item["Comment"],"Firefox ") !== false) { $group = "Firefox"; }
				if(strpos($item["Comment"],"Chrome ") !== false) { $group = "Chrome"; }
				if(strpos($item["Comment"],"Opera ") !== false) { $group = "Opera"; }
				if(strpos($item["Comment"],"Safari ") !== false) { $group = "Safari"; }
		
				// Fix key to be a valid regex
				$q_s=array("#\.#","#\*#","#\?#","#\(#","#\)#","#\[#","#\]#"); 
				$q_r=array("\.",".*",".?","\(","\)","\[","\]"); 
				$key = "^" . preg_replace($q_s,$q_r,$key) . "\$";
				
				// Store
				$major_browsers[$group][$key] = $item["Comment"];
			}
		
			if($verbose)
			{
				$count++;
				if(($count % 5000) == 0) { echo "."; }
			}
		}
	
		// ################################
		// PHASE 3 :: SORT AND SAVE RESULTS
		// ################################
		
		// Separate out the minor data
		$others = $major_browsers["Other"];
		unset($major_browsers["Other"]);
		
		// Re-order the major data by most popular browser
		$major_browsers = array_merge(
			$major_browsers["IE"],
			$major_browsers["Chrome"],
			$major_browsers["Firefox"],
			$major_browsers["Safari"],
			$major_browsers["Opera"]
		);
		
		if($verbose)
		{
			echo "\n";
			echo time() . " :: Done filtering!\n";
			echo "Major browsers: " . count($major_browsers) . "\n";
			echo "Crawlers: {$crawlers}\n";
			echo "Fakes: {$fakes}\n";
			echo "Others: " . count($others) . "\n";
			echo time() . " :: Writing...\n";
		}
	
		// Save the results
		file_put_contents($this->majorFile,json_encode($major_browsers));
		file_put_contents($this->minorFile,json_encode($others));
	
		if($verbose)
		{
			echo time() . " :: Done!\n";
		}
	}

}
